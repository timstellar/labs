
# Строковый калькулятор на C++

## Условие
Программа получает на вход уравнение. Калькулятор распознаёт знаки (+,-,*,/,^), вещественные и дробные числа (пишутся через точку), и функции (tg, ctg, exp, cos, sin). Также можно использовать скобки для повышения приоритета операции.

## Принцип работы

В основе калькулятора стоит обратная польская нотация. Особенностью этого алгоритма считается преобразование приоритета в последовательность действий. Например, у нас есть выражение `a + b * c`. Если мы будем смотреть на это выражение со стороны кода, то мы должны будем определить последовательность действий и выполнить их по очереди. Проблемы начинаются с появлением скобок. Выражение `(a + b) * c` требует учитывать скобки и смотреть на приоритет действий. В польской нотации всё гораздо проще. Выражение `a + b * c` превращается в `bc*a+`, а `(a + b) * c` в `ab+c*`. Можно заметить, что знаки пишутся после чисел. Это значит, что это можно реализовать с помощью стека. Для этого мы будем брать числа и заносить их в стек, а как только появится оператор будем произвдить вычисления и заносить в стек ответ для следующих манипуляций.

## Проверка уравнения

Для проверки я использовал перебор строки. Программа проверяет количество скобок, наличие операторов по краям, сдвоенные операторы, неизвестные операторы.

Сразу в функции проверки `void Calculator::checkExpression()` я реализовал указание переменной `Х`. Весь ввод пользователя обёрнуть конструкцией `try {} catch (...) {}` с отладкой ошибок. Также я добавил пробелы между операторами, чтобы легко найти числа через `std::istringstream`.

## Перевод из обычного выражения в польскую нотацию

Для реализации этого функционала я сделал 2 вспомогательные функции: `int precendence(char op)` и `int isOperator(char c)`. Первая проставляет приоритет операции, а вторая проверяет, является ли символ оператором. Сам алгоритм работает с помощью перебора. В основе стоит `std::vector<std::string> output` и `std::stack<char> operators`. Далее идёт 4 проверки. Первая - на числа - если элемент таковым является, то сразу заносится в `output`. Вторая и третья - на скобки. Открывающуюся сразу заносим в `operators`, а закрывающуюся проверяем на наличие открывающейся ранее и чтобы закрывающаяся не шла сразу после открывающейся. Последняя проверка на операторы. Проверяем, чтобы он был не первым (т.к. тогда не будет работать приоритетность) и проверяем, чтобы его приоритет был больше предыдущего.
В конце просто перебираем оставшиеся операторы и записываем результат.

## Решение задачи с помощью польской нотации

Чтобы решить эту задачу, нужно перебрать все операторы и числа из предыдущего пункта. Первые 2 числа мы поместим в стек, после них 100% должен идти знак, поэтому с помощью `stack.top()` и `stack.pop()` забираем числа и производим вычисления. Аналогично выполняется и для функций `cos()`, `sin()` и т.п.



